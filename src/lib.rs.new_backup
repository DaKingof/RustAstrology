use leptos::*;
use wasm_bindgen::prelude::*;
use web_sys::{CanvasRenderingContext2d, HtmlCanvasElement};
use std::f64::consts::PI;

// Harmonic types
#[derive(Debug, Clone, Copy, PartialEq)]
enum HarmonicType {
    Second = 2,
    Third = 3,
    Fourth = 4,
    Fifth = 5,
    Sixth = 6,
    Seventh = 7,
    Eighth = 8,
    Ninth = 9,
    Tenth = 10,
    Eleventh = 11,
    Twelfth = 12,
    Sixteenth = 16,
}

impl HarmonicType {
    fn value(&self) -> u32 {
        *self as u32
    }

    fn display_name(&self) -> String {
        match self {
            Self::Second => "2nd".to_string(),
            Self::Third => "3rd".to_string(),
            Self::Fourth => "4th".to_string(),
            Self::Fifth => "5th".to_string(),
            Self::Sixth => "6th".to_string(),
            Self::Seventh => "7th".to_string(),
            Self::Eighth => "8th".to_string(),
            Self::Ninth => "9th".to_string(),
            Self::Tenth => "10th".to_string(),
            Self::Eleventh => "11th".to_string(),
            Self::Twelfth => "12th".to_string(),
            Self::Sixteenth => "16th".to_string(),
        }
    }

    fn harmonic_range(&self) -> f64 {
        360.0 / self.value() as f64
    }
}

// Planet data structure
#[derive(Debug, Clone)]
struct Planet {
    name: &'static str,
    symbol: &'static str,
    longitude: f64,
    color: &'static str,
}

// US Sibley Chart data
fn get_sibley_chart() -> Vec<Planet> {
    vec![
        Planet { name: "Sun", symbol: "☉", longitude: 13.0, color: "#FFD700" },
        Planet { name: "Moon", symbol: "☽", longitude: 76.0, color: "#C0C0C0" },
        Planet { name: "Mercury", symbol: "☿", longitude: 95.0, color: "#FFA500" },
        Planet { name: "Venus", symbol: "♀", longitude: 63.0, color: "#90EE90" },
        Planet { name: "Mars", symbol: "♂", longitude: 52.0, color: "#FF6347" },
        Planet { name: "Jupiter", symbol: "♃", longitude: 18.0, color: "#1E90FF" },
        Planet { name: "Saturn", symbol: "♄", longitude: 350.0, color: "#8B4513" },
        Planet { name: "Uranus", symbol: "♅", longitude: 56.0, color: "#00CED1" },
        Planet { name: "Neptune", symbol: "♆", longitude: 162.0, color: "#4169E1" },
        Planet { name: "Pluto", symbol: "♇", longitude: 274.0, color: "#8B0000" },
    ]
}

// Canvas constants
const CANVAS_SIZE: f64 = 400.0;
const CENTER_X: f64 = 200.0;
const CENTER_Y: f64 = 200.0;
const RADIUS: f64 = 170.0;
const PLANET_RADIUS: f64 = 150.0;

// Helper functions
fn degrees_to_coords(degrees: f64, radius: f64) -> (f64, f64) {
    let radians = (90.0 - degrees) * PI / 180.0;
    let x = CENTER_X + radius * radians.cos();
    let y = CENTER_Y - radius * radians.sin();
    (x, y)
}

// Calculate the arithmetic mean of two angles, handling wrap-around
fn calculate_360_midpoint(pos1: f64, pos2: f64) -> f64 {
    // Ensure positions are in range 0-359.99
    let p1 = ((pos1 % 360.0) + 360.0) % 360.0;
    let p2 = ((pos2 % 360.0) + 360.0) % 360.0;
    
    // Calculate direct average
    let mut midpoint = (p1 + p2) / 2.0;
    
    // Handle case where the arc crosses 0°
    if (p1 - p2).abs() > 180.0 {
        midpoint = (midpoint + 180.0) % 360.0;
    }
    
    midpoint
}

// Calculate the harmonic midpoint between two positions
fn calculate_harmonic_midpoint(pos1: f64, pos2: f64, harmonic_base: f64) -> f64 {
    // First calculate the 360° midpoint
    let midpoint_360 = calculate_360_midpoint(pos1, pos2);
    
    // Convert to harmonic position (fold into the harmonic range)
    let harmonic_range = 360.0 / harmonic_base;
    midpoint_360 % harmonic_range
}

// Calculate all midpoints for a set of planets
fn calculate_all_midpoints(planets: &[Planet]) -> Vec<(f64, usize, usize)> {
    let mut midpoints = Vec::new();
    
    // Calculate midpoints for all unique pairs
    for (i, p1) in planets.iter().enumerate() {
        for (j, p2) in planets.iter().enumerate().skip(i + 1) {
            let midpoint_360 = calculate_360_midpoint(p1.longitude, p2.longitude);
            
            // Store the midpoint with indices to the planets
            midpoints.push((midpoint_360, i, j));
        }
    }
    
    midpoints
}

// Helper to get planet pairs for midpoints
fn get_planet_pairs_for_midpoints(planets: &[Planet]) -> Vec<(f64, usize, usize)> {
    calculate_all_midpoints(planets)
}

fn format_degree(degree: f64) -> String {
    let d = degree as i32;
    let m = ((degree - d as f64) * 60.0) as i32;
    format!("{}°{:02}'", d, m)
}

// Left dial - 360° with planets and midpoints
#[component]
fn LeftDial(
    current_harmonic: ReadSignal<HarmonicType>,
    shared_rotation: ReadSignal<f64>,
    set_shared_rotation: WriteSignal<f64>
) -> impl IntoView {
    let canvas_ref = create_node_ref::<leptos::html::Canvas>();
    let (is_dragging, set_is_dragging) = create_signal(false);
    let (last_angle, set_last_angle) = create_signal(0.0);
    
    let planets = get_sibley_chart();
    let midpoint_pairs = get_planet_pairs_for_midpoints(&planets);

    let get_angle_from_mouse = move |event: &web_sys::MouseEvent| {
        if let Some(canvas) = canvas_ref.get() {
            let canvas_element: HtmlCanvasElement = (*canvas).clone().unchecked_into();
            let rect = canvas_element.get_bounding_client_rect();
            let x = event.client_x() as f64 - rect.left();
            let y = event.client_y() as f64 - rect.top();
            let dx = x - CENTER_X;
            let dy = y - CENTER_Y;
            dy.atan2(dx) * 180.0 / PI
        } else {
            0.0
        }
    };

    let handle_mouse_down = move |event: web_sys::MouseEvent| {
        set_is_dragging.set(true);
        set_last_angle.set(get_angle_from_mouse(&event));
    };

    let handle_mouse_up = move |_| {
        set_is_dragging.set(false);
    };

    let handle_mouse_move = move |event: web_sys::MouseEvent| {
        if is_dragging.get() {
            let current_angle = get_angle_from_mouse(&event);
            let angle_diff = current_angle - last_angle.get();
            set_shared_rotation.update(|r| *r = (*r + angle_diff + 360.0) % 360.0);
            set_last_angle.set(current_angle);
        }
    };

    let render_dial = move || {
        if let Some(canvas) = canvas_ref.get() {
            let canvas_element: HtmlCanvasElement = (*canvas).clone().unchecked_into();
            if let Ok(Some(context)) = canvas_element.get_context("2d") {
                if let Ok(context) = context.dyn_into::<CanvasRenderingContext2d>() {
                    context.clear_rect(0.0, 0.0, CANVAS_SIZE, CANVAS_SIZE);
                    
                    let harmonic = current_harmonic.get();
                    let rot = shared_rotation.get();
                    
                    // Main circle
                    context.set_stroke_style(&"#ffffff".into());
                    context.set_line_width(2.0);
                    context.begin_path();
                    context.arc(CENTER_X, CENTER_Y, RADIUS, 0.0, 2.0 * PI).unwrap();
                    context.stroke();
                    
                    // Arms based on harmonic - multiply by 4 as requested
                    let num_arms = harmonic.value() * 4;
                    
                    context.set_stroke_style(&"#666666".into());
                    context.set_line_width(1.0);
                    for i in 0..num_arms {
                        let angle = (i as f64 * (360.0 / num_arms as f64) + rot) % 360.0;
                        let (x, y) = degrees_to_coords(angle, RADIUS);
                        context.begin_path();
                        context.move_to(CENTER_X, CENTER_Y);
                        context.line_to(x, y);
                        context.stroke();
                        
                        // Add arrow to the 0° mark
                        if i == 0 {
                            let arrow_size = 10.0;
                            let angle_rad = (90.0 - angle) * PI / 180.0;
                            let x1 = x - arrow_size * (angle_rad + 0.3).cos();
                            let y1 = y + arrow_size * (angle_rad + 0.3).sin();
                            let x2 = x - arrow_size * (angle_rad - 0.3).cos();
                            let y2 = y + arrow_size * (angle_rad - 0.3).sin();
                            
                            context.begin_path();
                            context.move_to(x, y);
                            context.line_to(x1, y1);
                            context.line_to(x2, y2);
                            context.close_path();
                            context.set_fill_style(&"#ffffff".into());
                            context.fill();
                            context.set_fill_style(&"#666666".into());
                        }
                    
                    // Draw Inner Moving Harmonic Tick Marks and Labels (counter-clockwise numbering)
                    context.set_fill_style(&"#FFFFFF".into());
                    context.set_font("10px Arial");
                    context.set_text_align("center");
                    context.set_text_baseline("middle");
                    
                    let label_step = match harmonic.harmonic_range() {
                        hr if hr <= 30.0 => 1.0,  // e.g., 12th harmonic (30 deg range), label every 1 deg
                        hr if hr <= 60.0 => 5.0,  // e.g., 6th harmonic (60 deg range), label every 5 deg
                        hr if hr <= 90.0 => 5.0,  // e.g., 4th harmonic (90 deg range), label every 5 deg
                        hr if hr <= 120.0 => 10.0, // e.g., 3rd harmonic (120 deg range), label every 10 deg
                        _ => 15.0,                 // e.g., 2nd harmonic (180 deg range), label every 15 deg
                    };
                    
                    let mut h_deg = 0.0;
                    while h_deg < harmonic.harmonic_range() {
                        // Draw inner tick mark that rotates with the dial
                        // Note: We're using counter-clockwise numbering as requested
                        // For the visual canvas, 0 is at the top and we count counter-clockwise
                        
                        // The tick mark's position is h_deg in the harmonic space
                        // Add the rotation to make it move with the dial
                        let tick_angle = (rot + h_deg) % 360.0;
                        
                        context.set_stroke_style(&"#CCCCCC".into());
                        context.set_line_width(1.0);
                        let (tick_x1, tick_y1) = degrees_to_coords(tick_angle, RADIUS - 2.0);
                        let (tick_x2, tick_y2) = degrees_to_coords(tick_angle, RADIUS - 15.0);
                        context.begin_path();
                        context.move_to(tick_x1, tick_y1);
                        context.line_to(tick_x2, tick_y2);
                        context.stroke();
                        
                        // Draw label
                        let (lx, ly) = degrees_to_coords(tick_angle, RADIUS - 25.0);
                        context.fill_text(&format!("{}", h_deg as i32), lx, ly).unwrap();
                        
                        h_deg += label_step;
                    }
                    
                    // Draw midpoint lines on the chart for active arms
                    context.set_stroke_style(&"rgba(255,255,255,0.3)".into());
                    context.set_line_width(1.0);
                    
                    // Calculate arm angles
                    let arm_angles = (0..num_arms)
                        .map(|i| (i as f64 * (360.0 / num_arms as f64) + rot) % 360.0)
                        .collect::<Vec<f64>>();
                    
                    // Calculate which midpoints are active (within 1 degree of any arm)
                    let active_midpoints = midpoint_pairs.iter().filter(|&&(mp, _, _)| {
                        arm_angles.iter().any(|&arm_angle| {
                            let diff = (mp - arm_angle + 360.0) % 360.0;
                            diff < 1.0 || diff > 359.0 || (diff - 180.0).abs() < 1.0
                        })
                    }).collect::<Vec<_>>();

                    // Draw connection lines for active midpoints
                    for &(_, p1_idx, p2_idx) in &active_midpoints {
                        let p1 = &planets[*p1_idx];
                        let p2 = &planets[*p2_idx];
                        
                        // Calculate positions
                        let (x1, y1) = degrees_to_coords(p1.longitude, RADIUS + 25.0);
                        let (x2, y2) = degrees_to_coords(p2.longitude, RADIUS + 25.0);
                        
                        // Draw line between planets
                        context.begin_path();
                        context.move_to(x1, y1);
                        context.line_to(x2, y2);
                        context.stroke();
                    }
                    
                    // Draw planets OUTSIDE the dial with fixed positions and tick marks
                    context.set_font("14px Arial");
                    for planet in &planets {
                        // Fixed planet position (doesn't rotate with dial)
                        let (px, py) = degrees_to_coords(planet.longitude, RADIUS + 25.0);
                        
                        // Draw tick mark from dial edge to planet
                        context.set_stroke_style(&"#999999".into());
                        context.set_line_width(1.0);
                        let (tx1, ty1) = degrees_to_coords(planet.longitude, RADIUS);
                        let (tx2, ty2) = degrees_to_coords(planet.longitude, RADIUS + 20.0);
                        context.begin_path();
                        context.move_to(tx1, ty1);
                        context.line_to(tx2, ty2);
                        context.stroke();
                        
                        // Draw planet symbol
                        context.set_fill_style(&planet.color.into());
                        let _ = context.fill_text(&planet.symbol, px - 7.0, py + 5.0);
                    }
                }
            }
        }
    };

    create_effect(move |_| {
        current_harmonic.track();
        shared_rotation.track();
        render_dial();
    });

    view! {
        <div style="margin: 10px;">
            <h3 style="color: #fff; margin: 5px 0; font-size: 16px;">"360° Dial"</h3>
            <canvas 
                node_ref=canvas_ref 
                width=CANVAS_SIZE 
                height=CANVAS_SIZE
                style="cursor: move; border: 1px solid #444;"
                on:mousedown=handle_mouse_down
                on:mouseup=handle_mouse_up
                on:mousemove=handle_mouse_move
            />
        </div>
    }
}

// Right dial - Harmonic with planets
#[component]
fn RightDial(
    current_harmonic: ReadSignal<HarmonicType>,
    shared_rotation: ReadSignal<f64>,
    set_shared_rotation: WriteSignal<f64>
) -> impl IntoView {
    let canvas_ref = create_node_ref::<leptos::html::Canvas>();
    let (is_dragging, set_is_dragging) = create_signal(false);
    let (last_angle, set_last_angle) = create_signal(0.0);
    let planets = get_sibley_chart();
    let midpoint_pairs = get_planet_pairs_for_midpoints(&planets);

    let get_angle_from_mouse = move |event: &web_sys::MouseEvent| {
        if let Some(canvas) = canvas_ref.get() {
            let canvas_element: HtmlCanvasElement = (*canvas).clone().unchecked_into();
            let rect = canvas_element.get_bounding_client_rect();
            let x = event.client_x() as f64 - rect.left();
            let y = event.client_y() as f64 - rect.top();
            let dx = x - CENTER_X;
            let dy = y - CENTER_Y;
            dy.atan2(dx) * 180.0 / PI
        } else {
            0.0
        }
    };

    let handle_mouse_down = move |event: web_sys::MouseEvent| {
        set_is_dragging.set(true);
        set_last_angle.set(get_angle_from_mouse(&event));
    };

    let handle_mouse_up = move |_| {
        set_is_dragging.set(false);
    };

    let handle_mouse_move = move |event: web_sys::MouseEvent| {
        if is_dragging.get() {
            let current_angle = get_angle_from_mouse(&event);
            let angle_diff = current_angle - last_angle.get();
            set_shared_rotation.update(|r| *r = (*r + angle_diff + 360.0) % 360.0);
            set_last_angle.set(current_angle);
        }
    };

    let render_dial = move || {
        if let Some(canvas) = canvas_ref.get() {
            let canvas_element: HtmlCanvasElement = (*canvas).clone().unchecked_into();
            if let Ok(Some(context)) = canvas_element.get_context("2d") {
                if let Ok(context) = context.dyn_into::<CanvasRenderingContext2d>() {
                    context.clear_rect(0.0, 0.0, CANVAS_SIZE, CANVAS_SIZE);
                    let harmonic = current_harmonic.get();
                    let harmonic_range = harmonic.harmonic_range();
                    let rot = shared_rotation.get();
                    
                    // Circle
                    context.set_stroke_style(&"#ffffff".into());
                    context.set_line_width(2.0);
                    context.begin_path();
                    context.arc(CENTER_X, CENTER_Y, RADIUS, 0.0, 2.0 * PI).unwrap();
                    context.stroke();
                    
                    // Draw tick marks every 5 degrees
                    context.set_stroke_style(&"#666666".into());
                    context.set_line_width(1.0);
                    for i in 0..72 {
                        let degree = i as f64 * 5.0;
                        let tick_length = if degree % 30.0 == 0.0 { 10.0 } else { 5.0 };
                        let (x1, y1) = degrees_to_coords(degree, RADIUS);
                        let (x2, y2) = degrees_to_coords(degree, RADIUS - tick_length);
                        context.begin_path();
                        context.move_to(x1, y1);
                        context.line_to(x2, y2);
                        context.stroke();
                    }
                    
                    // Draw Inner Moving Harmonic Tick Marks and Labels (counter-clockwise numbering)
                    context.set_fill_style(&"#FFFFFF".into());
                    context.set_font("10px Arial");
                    context.set_text_align("center");
                    context.set_text_baseline("middle");
                    
                    let label_step = match harmonic_range {
                        hr if hr <= 30.0 => 1.0,  // e.g., 12th harmonic (30 deg range), label every 1 deg
                        hr if hr <= 60.0 => 5.0,  // e.g., 6th harmonic (60 deg range), label every 5 deg
                        hr if hr <= 90.0 => 5.0,  // e.g., 4th harmonic (90 deg range), label every 5 deg
                        hr if hr <= 120.0 => 10.0, // e.g., 3rd harmonic (120 deg range), label every 10 deg
                        _ => 15.0,                 // e.g., 2nd harmonic (180 deg range), label every 15 deg
                    };
                    
                    let mut h_deg = 0.0;
                    while h_deg < harmonic_range {
                        // Draw inner tick mark that rotates with the dial
                        // Note: We're using counter-clockwise numbering as requested
                        // For the visual canvas, 0 is at the top and we count counter-clockwise
                        
                        // The tick mark's position is h_deg in the harmonic space
                        // Add the rotation to make it move with the dial
                        let tick_angle = (rot + h_deg) % 360.0;
                        
                        context.set_stroke_style(&"#CCCCCC".into());
                        context.set_line_width(1.0);
                        let (tick_x1, tick_y1) = degrees_to_coords(tick_angle, RADIUS - 2.0);
                        let (tick_x2, tick_y2) = degrees_to_coords(tick_angle, RADIUS - 15.0);
                        context.begin_path();
                        context.move_to(tick_x1, tick_y1);
                        context.line_to(tick_x2, tick_y2);
                        context.stroke();
                        
                        // Draw label
                        let (lx, ly) = degrees_to_coords(tick_angle, RADIUS - 25.0);
                        context.fill_text(&format!("{}", h_deg as i32), lx, ly).unwrap();
                        
                        h_deg += label_step;
                    }
                    
                    // 4 Arms with static degree labels showing what they point to at 0 rotation
                    context.set_stroke_style(&"#666666".into());
                    context.set_line_width(1.5);
                    context.set_font("12px Arial");
                    context.set_fill_style(&"#ffffff".into());
                    
                    for i in 0..4 {
                        // Calculate the angle of this arm in the current rotation
                        let angle = (i as f64 * 90.0 + rot) % 360.0;
                        let (x, y) = degrees_to_coords(angle, RADIUS);
                        
                        // Draw arm
                        context.begin_path();
                        context.move_to(CENTER_X, CENTER_Y);
                        context.line_to(x, y);
                        context.stroke();
                        
                        // Add arrow to the 0° mark
                        if i == 0 {
                            let arrow_size = 10.0;
                            let angle_rad = (90.0 - angle) * PI / 180.0;
                            let x1 = x - arrow_size * (angle_rad + 0.3).cos();
                            let y1 = y + arrow_size * (angle_rad + 0.3).sin();
                            let x2 = x - arrow_size * (angle_rad - 0.3).cos();
                            let y2 = y + arrow_size * (angle_rad - 0.3).sin();
                            
                            context.begin_path();
                            context.move_to(x, y);
                            context.line_to(x1, y1);
                            context.line_to(x2, y2);
                            context.close_path();
                            context.set_fill_style(&"#ffffff".into());
                            context.fill();
                        }
                    
                    // Draw midpoint lines for active arms similar to left dial
                    context.set_stroke_style(&"rgba(255,255,255,0.3)".into());
                    context.set_line_width(1.0);
                    
                    // Calculate visual arm angles
                    let arm_angles_visual = (0..4)
                        .map(|i| (i as f64 * 90.0 + rot) % 360.0)
                        .collect::<Vec<f64>>();
                    
                    // Find active midpoints from the active ones in the left dial
                    // but transform to harmonic position
                    let active_midpoints = midpoint_pairs.iter().filter(|&&(mp, _, _)| {
                        // Calculate the harmonic midpoint by folding the 360° midpoint
                        let harmonic_mp = mp % harmonic_range;
                        
                        arm_angles_visual.iter().any(|&arm_angle_visual| {
                            let arm_pos_effective = (arm_angle_visual * harmonic_range / 360.0);
                            let diff = (harmonic_mp - arm_pos_effective + harmonic_range) % harmonic_range;
                            let opposition_point = harmonic_range / 2.0;
                            diff < 1.0 || diff > (harmonic_range - 1.0) || (diff - opposition_point).abs() < 1.0
                        })
                    }).collect::<Vec<_>>();
                    }
                    
                    // Draw Inner Moving Harmonic Tick Marks and Labels (counter-clockwise numbering)
                    context.set_fill_style(&"#FFFFFF".into());
                    context.set_font("10px Arial");
                    context.set_text_align("center");
                    context.set_text_baseline("middle");
                    
                    let label_step = match harmonic_range {
                        hr if hr <= 30.0 => 1.0,  // e.g., 12th harmonic (30 deg range), label every 1 deg
                        hr if hr <= 60.0 => 5.0,  // e.g., 6th harmonic (60 deg range), label every 5 deg
                        hr if hr <= 90.0 => 5.0,  // e.g., 4th harmonic (90 deg range), label every 5 deg
                        hr if hr <= 120.0 => 10.0, // e.g., 3rd harmonic (120 deg range), label every 10 deg
                        _ => 15.0,                 // e.g., 2nd harmonic (180 deg range), label every 15 deg
                    };
                    
                    let mut h_deg = 0.0;
                    while h_deg < harmonic_range {
                        // Draw inner tick mark that rotates with the dial
                        // Note: We're using counter-clockwise numbering as requested
                        // For the visual canvas, 0 is at the top and we count counter-clockwise
                        
                        // The tick mark's position is h_deg in the harmonic space
                        // Add the rotation to make it move with the dial
                        let tick_angle = (rot + h_deg) % 360.0;
                        
                        context.set_stroke_style(&"#CCCCCC".into());
                        context.set_line_width(1.0);
                        let (tick_x1, tick_y1) = degrees_to_coords(tick_angle, RADIUS - 2.0);
                        let (tick_x2, tick_y2) = degrees_to_coords(tick_angle, RADIUS - 15.0);
                        context.begin_path();
                        context.move_to(tick_x1, tick_y1);
                        context.line_to(tick_x2, tick_y2);
                        context.stroke();
                        
                        // Draw label
                        let (lx, ly) = degrees_to_coords(tick_angle, RADIUS - 25.0);
                        context.fill_text(&format!("{}", h_deg as i32), lx, ly).unwrap();
                        
                        h_deg += label_step;
                    }).collect::<Vec<_>>();

                    // Draw connection lines for active midpoints
                    for &(_, p1_idx, p2_idx) in &active_midpoints {
                        let p1 = &planets[*p1_idx];
                        let p2 = &planets[*p2_idx];
                        
                        // Calculate effective harmonic positions (folded into the segment)
                        let p1_harm_pos_eff = p1.longitude % harmonic_range;
                        let p2_harm_pos_eff = p2.longitude % harmonic_range;
                        
                        // Calculate coordinates using direct effective harmonic positions for plotting
                        let (x1, y1) = degrees_to_coords(p1_harm_pos_eff, RADIUS + 25.0);
                        let (x2, y2) = degrees_to_coords(p2_harm_pos_eff, RADIUS + 25.0);
                        
                        // Draw line between planets
                        context.begin_path();
                        context.move_to(x1, y1);
                        context.line_to(x2, y2);
                        context.stroke();
                    }
                    
                    // Harmonic Planets (fixed outside dial)
                    context.set_font("14px Arial");
                    for planet in &planets {
                        // Calculate effective position within the harmonic range
                        // For a planet at 181° on 4th harmonic (90° range), this would be 181 % 90 = 1°
                        let harmonic_pos_eff = planet.longitude % harmonic_range;
                        
                        // Use direct effective harmonic position for plotting
                        let (px, py) = degrees_to_coords(harmonic_pos_eff, RADIUS + 25.0);
                        
                        // Draw outer static tick mark for planet
                        context.set_stroke_style(&"#999999".into());
                        context.set_line_width(1.0);
                        let (tx1, ty1) = degrees_to_coords(harmonic_pos_eff, RADIUS);
                        let (tx2, ty2) = degrees_to_coords(harmonic_pos_eff, RADIUS + 20.0);
                        context.begin_path();
                        context.move_to(tx1, ty1);
                        context.line_to(tx2, ty2);
                        context.stroke();
                        
                        // Draw planet symbol
                        context.set_fill_style(&planet.color.into());
                        let _ = context.fill_text(&planet.symbol, px - 5.0, py + 5.0);
                    }
                    
                    // Draw Inner Moving Harmonic Tick Marks and Labels
                    context.set_fill_style(&"#FFFFFF".into());
                    context.set_font("10px Arial");
                    context.set_text_align("center");
                    context.set_text_baseline("middle");
                    
                    let label_step = match harmonic_range {
                        hr if hr <= 30.0 => 1.0,  // e.g., 12th harmonic (30 deg range), label every 1 deg
                        hr if hr <= 60.0 => 5.0,  // e.g., 6th harmonic (60 deg range), label every 5 deg
                        hr if hr <= 90.0 => 5.0,  // e.g., 4th harmonic (90 deg range), label every 5 deg
                        hr if hr <= 120.0 => 10.0, // e.g., 3rd harmonic (120 deg range), label every 10 deg
                        _ => 15.0,                 // e.g., 2nd harmonic (180 deg range), label every 15 deg
                    }
                    
                    // Draw Inner Moving Harmonic Tick Marks and Labels (counter-clockwise numbering)
                    context.set_fill_style(&"#FFFFFF".into());
                    context.set_font("10px Arial");
                    context.set_text_align("center");
                    context.set_text_baseline("middle");
                    
                    let label_step = match harmonic_range {
                        hr if hr <= 30.0 => 1.0,  // e.g., 12th harmonic (30 deg range), label every 1 deg
                        hr if hr <= 60.0 => 5.0,  // e.g., 6th harmonic (60 deg range), label every 5 deg
                        hr if hr <= 90.0 => 5.0,  // e.g., 4th harmonic (90 deg range), label every 5 deg
                        hr if hr <= 120.0 => 10.0, // e.g., 3rd harmonic (120 deg range), label every 10 deg
                        _ => 15.0,                 // e.g., 2nd harmonic (180 deg range), label every 15 deg
                    };
                    
                    let mut h_deg = 0.0;
                    while h_deg < harmonic_range {
                        // Draw inner tick mark that rotates with the dial
                        // Note: We're using counter-clockwise numbering as requested
                        // For the visual canvas, 0 is at the top and we count counter-clockwise
                        
                        // The tick mark's position is h_deg in the harmonic space
                        // Add the rotation to make it move with the dial
                        let tick_angle = (rot + h_deg) % 360.0;
                        
                        context.set_stroke_style(&"#CCCCCC".into());
                        context.set_line_width(1.0);
                        let (tick_x1, tick_y1) = degrees_to_coords(tick_angle, RADIUS - 2.0);
                        let (tick_x2, tick_y2) = degrees_to_coords(tick_angle, RADIUS - 15.0);
                        context.begin_path();
                        context.move_to(tick_x1, tick_y1);
                        context.line_to(tick_x2, tick_y2);
                        context.stroke();
                        
                        // Draw label
                        let (lx, ly) = degrees_to_coords(tick_angle, RADIUS - 25.0);
                        context.fill_text(&format!("{}", h_deg as i32), lx, ly).unwrap();
                        
                        h_deg += label_step;
                    };
                    
                    let mut h_deg = 0.0;
                    while h_deg < harmonic_range {
                        // h_deg is the harmonic degree value (0, 5, 10, ... counting CCW from dial's 0)
                        // Calculate its visual span CCW from the dial's 0 point
                        let h_visual_span_ccw = h_deg * (360.0 / harmonic_range);
                        
                        // The dial's 0 point is visually at `rot` (CW from canvas top).
                        // So, the label for h_deg is `h_visual_span_ccw` CCW from `rot`.
                        // Final angle for degrees_to_coords (CW from canvas top):
                        let final_plot_angle_cw = (rot - h_visual_span_ccw + 360.0) % 360.0;
                        
                        // Draw inner tick mark
                        context.set_stroke_style(&"#CCCCCC".into());
                        context.set_line_width(1.0);
                        let (tick_x1, tick_y1) = degrees_to_coords(final_plot_angle_cw, RADIUS - 2.0);
                        let (tick_x2, tick_y2) = degrees_to_coords(final_plot_angle_cw, RADIUS - 8.0);
                        context.begin_path();
                        context.move_to(tick_x1, tick_y1);
                        context.line_to(tick_x2, tick_y2);
                        context.stroke();
                        
                        // Draw label
                        let (lx, ly) = degrees_to_coords(final_plot_angle_cw, RADIUS - 18.0);
                        context.fill_text(&format!("{}", h_deg as i32), lx, ly).unwrap();
                        
                        h_deg += label_step;
                    }
                    
                    // Draw Inner Moving Harmonic Tick Marks and Labels (counter-clockwise numbering)
                    context.set_fill_style(&"#FFFFFF".into());
                    context.set_font("10px Arial");
                    context.set_text_align("center");
                    context.set_text_baseline("middle");
                    
                    let label_step = match harmonic_range {
                        hr if hr <= 30.0 => 1.0,  // e.g., 12th harmonic (30 deg range), label every 1 deg
                        hr if hr <= 60.0 => 5.0,  // e.g., 6th harmonic (60 deg range), label every 5 deg
                        hr if hr <= 90.0 => 5.0,  // e.g., 4th harmonic (90 deg range), label every 5 deg
                        hr if hr <= 120.0 => 10.0, // e.g., 3rd harmonic (120 deg range), label every 10 deg
                        _ => 15.0,                 // e.g., 2nd harmonic (180 deg range), label every 15 deg
                    };
                    
                    let mut h_deg = 0.0;
                    while h_deg < harmonic_range {
                        // Draw inner tick mark that rotates with the dial
                        // Note: We're using counter-clockwise numbering as requested
                        // For the visual canvas, 0 is at the top and we count counter-clockwise
                        
                        // The tick mark's position is h_deg in the harmonic space
                        // Add the rotation to make it move with the dial
                        let tick_angle = (rot + h_deg) % 360.0;
                        
                        context.set_stroke_style(&"#CCCCCC".into());
                        context.set_line_width(1.0);
                        let (tick_x1, tick_y1) = degrees_to_coords(tick_angle, RADIUS - 2.0);
                        let (tick_x2, tick_y2) = degrees_to_coords(tick_angle, RADIUS - 15.0);
                        context.begin_path();
                        context.move_to(tick_x1, tick_y1);
                        context.line_to(tick_x2, tick_y2);
                        context.stroke();
                        
                        // Draw label
                        let (lx, ly) = degrees_to_coords(tick_angle, RADIUS - 25.0);
                        context.fill_text(&format!("{}", h_deg as i32), lx, ly).unwrap();
                        
                        h_deg += label_step;
                    }
                    
                    // Draw arrows at 0 degree mark (fixed relative to canvas, not dial)
                    // These indicate the actual 0, 90, 180, 270 of the harmonic space if dial is at 0 rot.
                }
            }
        }
    };

    create_effect(move |_| {
        current_harmonic.track();
        shared_rotation.track();
        render_dial();
    });

    view! {
        <div style="margin: 10px;">
            <h3 style="color: #fff; margin: 5px 0; font-size: 16px;">
                {move || format!("{}° Harmonic", current_harmonic.get().harmonic_range() as u32)}
            </h3>
            <canvas 
                node_ref=canvas_ref 
                width=CANVAS_SIZE 
                height=CANVAS_SIZE
                style="cursor: move; border: 1px solid #444;"
                on:mousedown=handle_mouse_down
                on:mouseup=handle_mouse_up
                on:mousemove=handle_mouse_move
            />
        </div>
    }
}
// Main app component
#[component]
pub fn App() -> impl IntoView {
    let (current_harmonic, set_current_harmonic) = create_signal(HarmonicType::Fourth);
    // Shared rotation signal for both dials
    let (shared_rotation, set_shared_rotation) = create_signal(0.0);

    view! {
        <div style="background-color: #1a1a1a; padding: 20px;">
            <h1 style="color: #fff; text-align: center; margin-bottom: 20px;">
                "Natal Astrology Chart Dials"
            </h1>
            <h2 style="color: #fff; text-align: center; margin-bottom: 30px;">
                "US Sibley Chart"
            </h2>
            
            <div style="display: flex; justify-content: center; gap: 40px; flex-wrap: wrap;">
                <LeftDial current_harmonic=current_harmonic shared_rotation=shared_rotation set_shared_rotation=set_shared_rotation/>
                <RightDial current_harmonic=current_harmonic shared_rotation=shared_rotation set_shared_rotation=set_shared_rotation/>
            </div>
            
            <div style="display: flex; justify-content: center; gap: 10px; margin-top: 30px; flex-wrap: wrap;">
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Second)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "2nd"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Third)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "3rd"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Fourth)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "4th"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Fifth)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "5th"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Sixth)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "6th"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Seventh)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "7th"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Eighth)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "8th"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Ninth)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "9th"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Tenth)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "10th"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Eleventh)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "11th"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Twelfth)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "12th"
                </button>
                <button 
                    on:click=move |_| set_current_harmonic.set(HarmonicType::Sixteenth)
                    style="padding: 8px 16px; background: #4a4a4a; color: white; border: 1px solid #666; cursor: pointer; margin: 5px;"
                >
                    "16th"
                </button>
            </div>
        </div>
    }
}

// Entry point for WASM
#[wasm_bindgen(start)]
pub fn main() {
    mount_to_body(App);
}
